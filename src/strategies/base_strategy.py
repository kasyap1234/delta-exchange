"""
Base Strategy Interface.
Defines the abstract base class that all trading strategies must implement.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional, Dict, Any
from datetime import datetime

from src.delta_client import DeltaExchangeClient, Position, Order


class StrategyType(str, Enum):
    """Types of trading strategies."""
    FUNDING_ARBITRAGE = "funding_arbitrage"
    CORRELATED_HEDGING = "correlated_hedging"
    MULTI_TIMEFRAME = "multi_timeframe"


class SignalDirection(str, Enum):
    """Direction of trading signal."""
    LONG = "long"
    SHORT = "short"
    NEUTRAL = "neutral"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


@dataclass
class StrategySignal:
    """
    Signal generated by a strategy.
    
    Contains all information needed to execute a trade.
    """
    strategy_type: StrategyType
    symbol: str
    direction: SignalDirection
    confidence: float  # 0.0 to 1.0
    entry_price: float
    position_size: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    hedge_symbol: Optional[str] = None
    hedge_size: Optional[float] = None
    hedge_direction: Optional[SignalDirection] = None
    reason: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)
    
    @property
    def is_actionable(self) -> bool:
        """Check if this signal requires action."""
        return self.direction != SignalDirection.NEUTRAL
    
    @property
    def has_hedge(self) -> bool:
        """Check if this signal includes a hedge."""
        return self.hedge_symbol is not None and self.hedge_size is not None


@dataclass
class StrategyPerformance:
    """Track performance metrics for a strategy."""
    strategy_type: StrategyType
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: float = 0.0
    max_drawdown: float = 0.0
    current_positions: int = 0
    total_funding_earned: float = 0.0  # For funding arbitrage
    
    @property
    def win_rate(self) -> float:
        """Calculate win rate."""
        if self.total_trades == 0:
            return 0.0
        return self.winning_trades / self.total_trades
    
    @property
    def avg_pnl_per_trade(self) -> float:
        """Calculate average P&L per trade."""
        if self.total_trades == 0:
            return 0.0
        return self.total_pnl / self.total_trades


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Each strategy implementation must:
    1. Define its capital allocation percentage
    2. Generate trading signals
    3. Track its own positions
    4. Manage risk within its allocation
    """
    
    def __init__(self, client: DeltaExchangeClient, 
                 capital_allocation: float = 0.0,
                 dry_run: bool = False):
        """
        Initialize the strategy.
        
        Args:
            client: Delta Exchange API client
            capital_allocation: Fraction of total capital allocated (0.0-1.0)
            dry_run: If True, don't execute real trades
        """
        self.client = client
        self.capital_allocation = capital_allocation
        self.dry_run = dry_run
        self.performance = StrategyPerformance(strategy_type=self.strategy_type)
        self.is_active = True
        self._positions: Dict[str, Position] = {}
    
    @property
    @abstractmethod
    def strategy_type(self) -> StrategyType:
        """Return the type of this strategy."""
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        """Return a human-readable name for this strategy."""
        pass
    
    @abstractmethod
    def analyze(self, available_capital: float, 
                current_positions: List[Position]) -> List[StrategySignal]:
        """
        Analyze the market and generate trading signals.
        
        Args:
            available_capital: Capital available for this strategy
            current_positions: Current open positions
            
        Returns:
            List of StrategySignal objects
        """
        pass
    
    @abstractmethod
    def should_trade(self) -> bool:
        """
        Check if conditions are favorable for trading.
        
        Returns:
            True if strategy should actively trade
        """
        pass
    
    def get_allocated_capital(self, total_capital: float) -> float:
        """
        Calculate capital allocated to this strategy.
        
        Args:
            total_capital: Total available capital
            
        Returns:
            Capital allocated to this strategy
        """
        return total_capital * self.capital_allocation
    
    def update_positions(self, positions: List[Position]) -> None:
        """
        Update internal position tracking.
        
        Args:
            positions: Current positions from exchange
        """
        self._positions = {p.product_symbol: p for p in positions}
    
    def get_position(self, symbol: str) -> Optional[Position]:
        """
        Get position for a specific symbol.
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Position if exists, None otherwise
        """
        return self._positions.get(symbol)
    
    def has_position(self, symbol: str) -> bool:
        """Check if we have a position in this symbol."""
        pos = self.get_position(symbol)
        return pos is not None and pos.size != 0
    
    def record_trade(self, pnl: float, is_win: bool) -> None:
        """
        Record a completed trade for performance tracking.
        
        Args:
            pnl: Profit/loss of the trade
            is_win: Whether the trade was profitable
        """
        self.performance.total_trades += 1
        self.performance.total_pnl += pnl
        
        if is_win:
            self.performance.winning_trades += 1
        else:
            self.performance.losing_trades += 1
    
    def record_funding(self, amount: float) -> None:
        """
        Record funding income (for funding arbitrage strategy).
        
        Args:
            amount: Funding amount received
        """
        self.performance.total_funding_earned += amount
    
    def pause(self) -> None:
        """Pause this strategy (stop generating new signals)."""
        self.is_active = False
    
    def resume(self) -> None:
        """Resume this strategy."""
        self.is_active = True
    
    def get_status(self) -> Dict[str, Any]:
        """
        Get current strategy status.
        
        Returns:
            Dictionary with strategy status info
        """
        return {
            'name': self.name,
            'type': self.strategy_type.value,
            'is_active': self.is_active,
            'capital_allocation': self.capital_allocation,
            'performance': {
                'total_trades': self.performance.total_trades,
                'win_rate': self.performance.win_rate,
                'total_pnl': self.performance.total_pnl,
                'current_positions': len(self._positions)
            }
        }
